
# Worker's database

## Description
The task is to implement the CPersonalAgenda class, which will serve as an employee database.

To facilitate the HR department's work, we have an implemented employee database. For monitored employees, we remember their first name, last name, email, and salary. These details can change over time, and we want to be able to search for these details and have an overview of salaries.

An employee is identified by their name and surname or by their email. Company procedures ensure that the email is unique across the entire database. Furthermore, while names and surnames may repeat, the combination of (name, surname) is again unique in the database. Thus, the database may contain many people with the surname Svoboda, many may have the name Petr, but the employee Svoboda Petr can only be in the database once at any given time. When comparing names, surnames, and emails, case sensitivity is maintained.

The public interface is listed below. It includes the following:

A parameterless constructor. This constructor initializes an instance of the class so that the resulting instance is initially empty (contains no records).
Destructor. It frees resources allocated by the instance.

## Description of the public interface
* The **add(name, surname, email, salary)** method adds another record to the existing database. The parameters name and surname represent the first name and last name, the email parameter specifies the email address, and salary the salary. The method returns true if the record was added, or false if it was not added (because a record with the same name and surname or a record with the same email already exists in the database).
* The **del(name, surname) / del(email)** methods remove a record from the database. The parameter is a unique identification using a name and surname (first variant) or using an email (second variant). If the record was indeed removed, the method returns true. If the record was not removed (because an employee with this identification did not exist), the method returns false.
* The **changeName(email, newName, newSurname)** method changes an employee's name and surname. The employee is identified by the email email, and the employee's name is changed to newName/newSurname. The method returns true for success, false for failure (no employee with such an email exists, the newly assigned name/surname is not unique).
* The **changeEmail(name, surname, newEmail)** method changes an employee's email. The employee is identified by the name and surname name/surname, and the employee's email is changed to newEmail. The method returns true for success, false for failure (no employee with such a name and surname exists, the newly assigned email is not unique).
* The **setSalary(name, surname, salary) / setSalary(email, salary)** methods change the salary amount for a given employee. There are two variants - the employee is identified either by their name and surname or by their email address. If the method succeeds, it returns true, for failure it returns false (non-existent employee).
* The **getSalary(name, surname) / getSalary(email)** methods determine the salary amount of a given employee. There are two variants - the employee is identified either by their name and surname or by their email address. If the method succeeds, it returns the employee's salary amount, for failure (non-existent employee) it returns 0.
* The **getRank(name, surname, rankMin, rankMax) / getRank(email, rankMin, rankMax)** methods determine how well an employee is paid in relation to others. The result is the position of the given employee's salary on the imaginary ladder of salaries from the worst (lowest) to the best (highest). The parameter is the employee's identification (according to the variant either by name and surname or by email address), the parameters rankMin/rankMax are output, into which the function writes the position of the salary of the searched employee in the ladder. Because multiple employees can receive the same salary, the output is a pair of values - a min-max interval. If, for example, the searched employee receives a salary of 20000, 37 employees receive a lower salary and 21 other employees receive the same salary (thus, a total of 22 employees receive a salary of 20000), then the result is rankMin=37 and rankMax=37+22-1=58. The function's return value is true for success (the specified employee found, output parameters filled) or false (the specified employee not found, output parameters left unchanged).
* The **getFirst(outName, outSurname)** method is used for browsing the database. We want to browse employees alphabetically (sorted ascending by surname, in the case of identical surnames by name). The method returns the first employee in this sorted list, and writes his name and surname into the given output parameters outName/outSurname. The return value is true for success (the database was not empty) or false (empty database, output parameters left unchanged).
* The **getNext(name, surname, outName, outSurname)** method is used to browse employees in a similar way to the getFirst method. This method returns the next employee in the sorted list of employees (see getFirst) following the employee identified by name/surname. The name of the following employee is written to the given output parameters outName/outSurname. The return value is true for success (the employee name/surname was found and is not the last in the sorted list) or false for failure (the employee name/surname was not found or is the last in the list). In case of failure, the method does not change the output parameters outName/outSurname.

## General tips
Submit a file that contains the implemented CPersonalAgenda class. The class must meet the public interface as shown - if your submitted solution does not contain the described interface, a compilation error will occur. You can add additional methods (public or private) and member variables to the class. You can also add other support functions or classes to the submitted file. The submitted file must contain both the class declaration (interface description) and the definitions of methods, constructor, and destructor. It does not matter whether the methods are implemented inline or separately. The submitted file must not include header file inclusions and the main function (the main function and header file inclusions may remain but only if wrapped in conditional compilation directives). Use the attached source file as the basis for the implementation.

The class interface includes a number of methods in two variants, which differ only in the method of employee identification. It is advisable to spend non-zero time designing the class so that you do not have to copy all the executable code 2x (e.g., implement private methods that you will call from multiple public methods).

The class is tested in a limited environment where available memory is limited (sufficient to store the list) and the runtime is limited. The implemented class does not need to deal with a copying constructor or overloading the = operator. In this task, ProgTest does not conduct tests of this functionality.

The class implementation must be efficient in terms of time and memory requirements. Simple linear solutions are insufficient (for test data, they require time over 5 minutes). Assume that inserting and deleting an employee are significantly less frequent than other operations, thus here linear complexity is acceptable. Calls to getSalary and setSalary are frequent, their time complexity must be better than linear (e.g., logarithmic or amortized constant). Furthermore, methods getFirst/getNext should also be efficient, their complexity should also be better than linear.

In mandatory tests, the getRank method is called infrequently, so it does not have to be too efficient (linear or n log n complexity is sufficient for success in mandatory tests, but for the bonus test, the complexity needs to be better than linear. If you do not want to devise an efficient algorithm for the bonus test, focus on making the setSalary calls efficient even at the expense of a less efficient getRank method.

The bonus test can be solved in several ways. When designing a solution, you may use the knowledge that the given salary value is at most 1000000. Furthermore, knowing that salary values often repeat may help.

For storing values, allocate arrays dynamically or use the STL. However, if you are allocating arrays on your own, choose a small initial size (e.g., a thousand elements) and increase/decrease the size as needed. When an array is filled, it is not advisable to allocate a new array that is only one value larger, as such a procedure has a huge overhead for copying content. It is sensible to expand the array in steps of thousands of elements, or by a geometric series with a quotient of ~1.5 to 2.

If you use the STL, you don't have to worry about allocation problems. Be aware - only a part of the STL is available (see the header files in the attached example). Thus, for example, the containers map / unordered_map / set / unordered_set / ... are not available.

The attached source code contains basic tests. These tests by no means cover all situations, and you will need to expand them for debugging the class. Please note that tests contained in the submitted source codes are considered an integral part of your solution. If you leave foreign tests in your submitted solution, the work may be evaluated as plagiarized.

## More info:
Check skeletonToFill for infomation about the structure of the functions, and inputs/outputs 